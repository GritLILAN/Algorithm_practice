### 方法一：朴素筛法
#### 时间复杂度$O(nlog{n})$
#### 核心思路
用`st[]`数组表示某个数是否被标记过（筛过），若被标记过，则不是素数。
朴素筛法就是最暴力的做法，每遍历一个数`i`就用它筛掉后面的它的倍数。（不管这个数`i`是质数还是合数。
#### 代码
```cpp
void get_primes(){
    for(int i=2;i<=n;i++){

        if(!st[i]) primes[cnt++]=i;//把素数存起来
        for(int j=i;j<=n;j+=i){//不管是合数还是质数，都用来筛掉后面它的倍数
            st[j]=true;
        }
    }
}
```
### 方法二：埃氏筛法
#### 时间复杂度$O(nlog{log{n}})$
#### 核心思路
只用质数将后面的所有合数筛掉
#### 代码
```cpp
void get_primes(){
    for(int i=2;i<=n;i++){
        if(!st[i]){
            primes[cnt++]=i;
            for(int j=i;j<=n;j+=i) st[j]=true;//可以用质数就把所有的合数都筛掉；
        }
    }
}
```
### 方法三：线性筛
#### 时间复杂度$O(n)$
#### 核心思路
$\qquad$在埃氏筛法中，虽然只用质数筛掉后面的合数已经优化了时间复杂度，但是还会存在重复筛的情况，比如：
$$ 2 \times 3 = 6$$
$\qquad$这个式子中，数字`6`会被`2`和`3`各自筛一遍，也就是被重复筛了。对于每个要筛的合数，我们考虑只用它的最小质因数去筛，也就是说`6`只用`2`去筛，不用`3`筛。
$\qquad$在代码中，一层循环`for(int j = 0; primes[j] <= n/i; j++)`表示从最小的质数开始遍历，用`primes[j] * i`的乘积去筛。
$\qquad$要注意，如果`i % primes[j] == 0`要直接退出循环跳到下一个`i`去筛，为什么呢。假设`i * primes[j] == z`因为如果`i % primes[j] == 0`说明`primes[j]`是`z`的最小质因子，也是`i`的最小质因子，那么`prime[j + 1]`就不是`primes[j + 1] * i`的最小质因子，就不能继续用遍历`primes[]`中的质数了，因为越遍历越大不满足最小质因子。
$\qquad$举个例子，当前遍历到$i = 6,prime[j] = 2$ 的情况。
$$2 \times 6 = 12$$
$$3 \times 6 = 18$$
$$5 \times 6 = 30$$
很显然，`3`不是`18`的最小质因数，`5`不是`30`的最小质因数，在$prime[j] = 2$的情况下，已经知道了`2`才是`6`的最小质因数，所以比他大的质数`3、5`去乘`6`(也就是`i`)肯定重复筛了。