### 题目大意
首先是二叉树的遍历相关概念：
- 已知前序和中序遍历，可求后序遍历。
- 已知后序遍历和中序遍历，可求前序遍历。
- 但是已知前序遍历和后序遍历，无法确定唯一的中序遍历。
题目给出前序和后续遍历，要我们求出可能的中序遍历的数量。
### 解题思路
$\qquad$为什么第三种情况无法确定唯一的中序遍历，因为知道中序遍历的情况下可以确定左右子树，但是前序和后续都无法确定左右子树。所以第三种情况无法确定一棵树的具体形态。
$\qquad$那么如何判断有多少种可能的情况呢？
$\qquad$结合上面这一段，再举几个例子画画图，可以发现，那些只有一个子树（左子树或者右子树）的节点，是不确定的点。这类节点有两种中序遍历，即儿子在左或儿子在右。那么我们遍历得到这种节点的时候只需要`ans *= 2`即可。
$\qquad$那么该怎么确定这类节点呢，我们开2层循环，分别遍历前序和后序，如果出现了(`AB`，`BA`)这种组合，说明出现了一个独子节点。原因，前序是根左右，后序是左右根，如果不是独子，比如说`A`有两个孩子`B`和`C`，那么前序就是`ABC`，后序就是`BCA`。前序与根挨着的是左儿子`B`，后序与根挨着的是右儿子`C`。所以(`AB`，`BA`)这种组合`B`必然是`A`的独子。
### 代码
```cpp
#include<bits/stdc++.h>

using namespace std;

  

int res = 1;

  

int main(){

    string str1, str2;

    cin >> str1 >> str2;

    int len1 = str1.size(), len2 = str2.size();

  

    for(int i = 0; i < len1 - 1; i++){

        for(int j = len2 - 1; j > 0; j--){

            if(str1[i] == str2[j] && str1[i + 1] == str2[j - 1])

                res *= 2;

        }

    }

  

    cout << res << endl;

  

    return 0;

}
```