### 原题链接
https://www.lanqiao.cn/problems/3974/learning/
### 题目大意
$\qquad$有四个瓶子，每个瓶子中有`a[i]`个珍珠，每次操作可以使一个瓶子的珍珠数增加`2`，其他瓶子减少`1`。这个操作只有在其他三个瓶子珍珠数都大于`0`时才能进行，即如果当前有2个及以上瓶子为0则不能继续操作了。目标是使得四个瓶子中最多那个的瓶子珍珠数量最大。
### 解题思路
$\qquad$这个题目刚开始我以为就是直接往做多的瓶子里使劲加就行，结果肯定WA了。正解需要找规律分类讨论。
$\qquad$将数字从小到大排序，基本思想是：在四个数字中找到最大的一个令其不断加2，只要其他数字不递减到0就重复操作（为了不超时，直接让最大的数字加上2倍最小的数）；若出现一个`0`，则对其加`2`变成`2`，其他数减`1`，这样就又回到了没有`0`的状态，按照之前的思路继续操作。出现两个及以上`0`则退出。
$\qquad$基础思路有了，但是肯定有数据需要特判。经过举例找规律我们发现，如果有形如`a, a, a, b`或者`a b b b`的数据，即有3个相同的数字，按照上述思路操作会得出错误的结果。比如`0 5 5 5`经上述操作得到`9`，但是实际上一直对`0`累加的话，最终得到`10, 0, 0 , 0`正确答案是`10`。
$\qquad$特判情况说完了，再回到基础思路，基础思路是一个模拟的过程，但是数据范围`2e9`肯定会超时，而且最大值答案不一定循环的最后一步，有可能在过程中出现。优化代码思路：答案`MAX`不只取决于最小值，还跟次小值有关。`MAX = a[3] + 2 * a[0]`将最小值减成`0`后，可以直接得出答案：对次小值除以3取整再乘3，令`MAX`加上这个数，最后如果次小值对`3`取余等于2（即a[1] % 3 == 2），那么`MAX`再加`1`。
$\qquad$优化代码原理：为什么对次小值除3？因为模拟过程中每次循环过程最大值都加3，直到次小值不足3。看下面的例子：
`0, 7, 8, 9`
首先复活`0`，变成`2, 6, 7, 8`，然后将最小值再减成`0`，即`0, 4, 5, 12`。最大值从`7`变成`12`增加了3，次小值从`7`变成了`4`减少了3（次大值也是）。最后直到次小值不足`3`就不能这样操作了。对于次小值不足`3`的情况，就是取余分别为`0,1,2`三种情况，举例发现取余等于2是最特殊的，结果需要再`+1`。
举例如下：
`0, 5, 6, 7`
`2, 4, 5, 6`
`0, 2, 3, 10`
`2, 1, 2, 9`
`1, 0, 1, 11`
`0, 2, 0, 10`
其中，`5 / 3 = 1`，需要加`1 * 3`，另外`5 % 3 == 2`需要加`1`。
最大值是`7 + 1 * 3 + 1 = 11`。
### 代码
```cpp
#include<bits/stdc++.h>

#define int long long

using namespace std;

  

int a[4];

int res = 0;

  

int check(){

    if(a[0] == a[1] && a[1] == a[2] && a[2] == a[3]) return 1;

    if(a[1] == a[2] && a[2] == a[3]) return 1;

    if(a[0] == a[1] && a[1] == a[2]) return 2;

    return 0;

}

  

signed main(){

    for(int i = 0; i < 4; i++) cin >> a[i];

    sort(a, a + 4);

  

    if(check() == 1){

        res += a[0];

        res += 2 * a[3];

    }

    else if(check() == 2){

        res += a[3];

        res += 2 * a[0];

    }

    else{

        a[3] += a[0] * 2;

        res += a[3];

        a[1] -= a[0];

        res += a[1]/3 * 3;

        if(a[1] % 3 == 2) res++;

    }

  

    cout << res << endl;

  
  

    return 0;

}
```